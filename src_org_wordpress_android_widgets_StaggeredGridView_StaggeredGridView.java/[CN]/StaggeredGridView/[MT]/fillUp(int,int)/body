{
  final int paddingLeft=getPaddingLeft();
  final int paddingRight=getPaddingRight();
  final int itemMargin=mItemMargin;
  final int colWidth=(getWidth() - paddingLeft - paddingRight- itemMargin * (mColCount - 1)) / mColCount;
  mColWidth=colWidth;
  final int gridTop=getPaddingTop();
  final int fillTo=gridTop - overhang;
  int nextCol=getNextColumnUp();
  int position=fromPosition;
  while (nextCol >= 0 && mItemTops[nextCol] > fillTo && position >= 0) {
    if (!mColMappings.get(nextCol).contains((Integer)position)) {
      for (int i=0; i < mColMappings.size(); i++) {
        if (mColMappings.get(i).contains((Integer)position)) {
          nextCol=i;
          break;
        }
      }
    }
    final View child=obtainView(position,null);
    if (child == null)     continue;
    LayoutParams lp=(LayoutParams)child.getLayoutParams();
    if (lp == null) {
      lp=this.generateDefaultLayoutParams();
      child.setLayoutParams(lp);
    }
    if (child.getParent() != this) {
      if (mInLayout) {
        addViewInLayout(child,0,lp);
      }
 else {
        addView(child,0);
      }
    }
    final int span=Math.min(mColCount,lp.span);
    final int widthSize=colWidth * span + itemMargin * (span - 1);
    final int widthSpec=MeasureSpec.makeMeasureSpec(widthSize,MeasureSpec.EXACTLY);
    LayoutRecord rec;
    if (span > 1) {
      rec=getNextRecordUp(position,span);
      nextCol=0;
    }
 else {
      rec=mLayoutRecords.get(position);
    }
    boolean invalidateBefore=false;
    if (rec == null) {
      rec=new LayoutRecord();
      mLayoutRecords.put(position,rec);
      rec.column=nextCol;
      rec.span=span;
    }
 else     if (span != rec.span) {
      rec.span=span;
      rec.column=nextCol;
      invalidateBefore=true;
    }
 else {
    }
    if (mHasStableIds) {
      final long id=mAdapter.getItemId(position);
      rec.id=id;
      lp.id=id;
    }
    lp.column=nextCol;
    final int heightSpec;
    if (lp.height == LayoutParams.WRAP_CONTENT) {
      heightSpec=MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED);
    }
 else {
      heightSpec=MeasureSpec.makeMeasureSpec(lp.height,MeasureSpec.EXACTLY);
    }
    child.measure(widthSpec,heightSpec);
    final int childHeight=child.getMeasuredHeight();
    if (invalidateBefore || (childHeight != rec.height && rec.height > 0)) {
      invalidateLayoutRecordsBeforePosition(position);
    }
    rec.height=childHeight;
    int itemTop=mItemTops[nextCol];
    final int startFrom;
    if (span > 1) {
      int lowest=mItemTops[nextCol];
      final int colEnd=Math.min(mColCount,nextCol + lp.span);
      for (int i=nextCol; i < colEnd; i++) {
        final int top=mItemTops[i];
        if (top < lowest) {
          lowest=top;
        }
      }
      startFrom=lowest;
    }
 else {
      startFrom=mItemTops[nextCol];
    }
    int childBottom=startFrom;
    int childTop=childBottom - childHeight;
    final int childLeft=paddingLeft + nextCol * (colWidth + itemMargin);
    final int childRight=childLeft + child.getMeasuredWidth();
    child.layout(childLeft,childTop,childRight,childBottom);
    final int colEnd=Math.min(mColCount,nextCol + lp.span);
    for (int i=nextCol; i < colEnd; i++) {
      mItemTops[i]=childTop - itemMargin;
    }
    nextCol=getNextColumnUp();
    mFirstPosition=position--;
  }
  int highestView=getHeight();
  for (int i=0; i < getChildCount(); i++) {
    final View child=getChildAt(i);
    if (child == null) {
      break;
    }
    final int top=child.getTop();
    if (top < highestView) {
      highestView=top;
    }
  }
  return gridTop - highestView;
}
