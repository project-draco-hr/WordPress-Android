{
  final int paddingLeft=getPaddingLeft();
  final int paddingRight=getPaddingRight();
  final int itemMargin=mItemMargin;
  final int colWidth=(getWidth() - paddingLeft - paddingRight- itemMargin * (mColCount - 1)) / mColCount;
  final int gridBottom=getHeight() - getPaddingBottom();
  final int fillTo=gridBottom + overhang;
  int nextCol=getNextColumnDown(fromPosition);
  int position=fromPosition;
  while (nextCol >= 0 && mItemBottoms[nextCol] < fillTo && position < mItemCount) {
    final View child=obtainView(position,null);
    if (child == null)     continue;
    LayoutParams lp=(LayoutParams)child.getLayoutParams();
    if (lp == null) {
      lp=this.generateDefaultLayoutParams();
      child.setLayoutParams(lp);
    }
    if (child.getParent() != this) {
      if (mInLayout) {
        addViewInLayout(child,-1,lp);
      }
 else {
        addView(child);
      }
    }
    final int span=Math.min(mColCount,lp.span);
    final int widthSize=colWidth * span + itemMargin * (span - 1);
    final int widthSpec=MeasureSpec.makeMeasureSpec(widthSize,MeasureSpec.EXACTLY);
    LayoutRecord rec;
    if (span > 1) {
      rec=getNextRecordDown(position,span);
      nextCol=0;
    }
 else {
      rec=mLayoutRecords.get(position);
    }
    boolean invalidateAfter=false;
    if (rec == null) {
      rec=new LayoutRecord();
      mLayoutRecords.put(position,rec);
      rec.column=nextCol;
      rec.span=span;
    }
 else     if (span != rec.span) {
      rec.span=span;
      rec.column=nextCol;
      invalidateAfter=true;
    }
 else {
    }
    if (mHasStableIds) {
      final long id=mAdapter.getItemId(position);
      rec.id=id;
      lp.id=id;
    }
    lp.column=nextCol;
    final int heightSpec;
    if (lp.height == LayoutParams.WRAP_CONTENT) {
      heightSpec=MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED);
    }
 else {
      heightSpec=MeasureSpec.makeMeasureSpec(lp.height,MeasureSpec.EXACTLY);
    }
    child.measure(widthSpec,heightSpec);
    final int childHeight=child.getMeasuredHeight();
    if (invalidateAfter || (childHeight != rec.height && rec.height > 0)) {
      invalidateLayoutRecordsAfterPosition(position);
    }
    rec.height=childHeight;
    final int startFrom;
    if (span > 1) {
      int lowest=mItemBottoms[nextCol];
      for (int i=0; i < mColCount; i++) {
        final int bottom=mItemBottoms[i];
        if (bottom > lowest) {
          lowest=bottom;
        }
      }
      startFrom=lowest;
    }
 else {
      startFrom=mItemBottoms[nextCol];
    }
    final int childTop=startFrom + itemMargin;
    final int childBottom=childTop + childHeight;
    final int childLeft;
    if (span > 1) {
      childLeft=paddingLeft;
    }
 else {
      childLeft=paddingLeft + nextCol * (colWidth + itemMargin);
    }
    final int childRight=childLeft + child.getMeasuredWidth();
    child.layout(childLeft,childTop,childRight,childBottom);
    rec.left=childLeft;
    rec.top=childTop;
    rec.right=childRight;
    rec.bottom=childBottom;
    rec.hasRecRecord=true;
    if (!mColMappings.get(nextCol).contains(position)) {
      for (      ArrayList<Integer> list : mColMappings) {
        if (list.contains(position)) {
          list.remove((Integer)position);
        }
      }
      mColMappings.get(nextCol).add(position);
    }
    final int colEnd=Math.min(mColCount,nextCol + lp.span);
    for (int i=nextCol; i < colEnd; i++) {
      mItemBottoms[i]=childBottom + rec.getMarginBelow(i - nextCol);
    }
    position++;
    nextCol=getNextColumnDown(position);
  }
  int lowestView=0;
  for (int i=0; i < mColCount; i++) {
    if (mItemBottoms[i] > lowestView) {
      lowestView=mItemBottoms[i];
    }
  }
  return lowestView - gridBottom;
}
